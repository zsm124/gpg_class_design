from flask import Flask, render_template, request, redirect, url_for, flash, session
from flask_sqlalchemy import SQLAlchemy
import gnupg
import os
import tempfile
from pathlib import Path

app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///keys.db'
app.config['UPLOAD_FOLDER'] = tempfile.gettempdir()
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
app.secret_key = 'supersecretkey'

db = SQLAlchemy()

class Key(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name_email = db.Column(db.String(120), unique=True, nullable=False)
    public_key = db.Column(db.Text, nullable=False)
    private_key = db.Column(db.Text, nullable=False)
    passphrase = db.Column(db.String(120), nullable=False)
    fingerprint = db.Column(db.String(120), nullable=False)
    
db.init_app(app)

def get_default_gpg_home():
    """获取系统默认的GPG主目录"""
    if os.name == 'nt':  # Windows
        return os.path.join(os.environ.get('APPDATA', ''), 'gnupg')
    else:  # Linux/Mac
        return os.path.join(str(Path.home()), '.gnupg')

def ensure_gpg_permissions(gpg_home):
    """确保GPG目录有正确的权限"""
    if os.name != 'nt':  # 非Windows系统
        os.chmod(gpg_home, 0o700)
        for root, dirs, files in os.walk(gpg_home):
            for d in dirs:
                os.chmod(os.path.join(root, d), 0o700)
            for f in files:
                os.chmod(os.path.join(root, f), 0o600)

def get_gpg():
    """获取配置好的GPG对象"""
    gpg_home = get_default_gpg_home()
    os.makedirs(gpg_home, exist_ok=True)
    ensure_gpg_permissions(gpg_home)
    return gnupg.GPG(gnupghome=gpg_home)

@app.route('/')
def index():
    keys = Key.query.all()
    return render_template('index.html', keys=keys)    

@app.route('/keys')
def list_keys():
    keys = Key.query.all()
    return render_template('index.html', keys=keys)

@app.route('/generate_key', methods=['GET', 'POST'])
def generate_key():
    if request.method == 'POST':
        name_email = request.form['name_email']
        passphrase = request.form['passphrase']
        
        gpg = get_gpg()
        
        # 检查密钥是否已经存在
        existing_key = Key.query.filter_by(name_email=name_email).first()
        if existing_key:
            flash("该邮箱的密钥已存在。")
            return redirect(url_for('generate_key'))
        
        # 生成密钥输入
        input_data = gpg.gen_key_input(
            key_type='RSA',
            key_length=4096,
            name_email=name_email,
            passphrase=passphrase,
            name_real=name_email.split('@')[0],
            name_comment='Generated by GPG Manager'
        )
        
        key = gpg.gen_key(input_data)
        if not key:
            flash("密钥生成失败。")
            return redirect(url_for('generate_key'))
        
        public_key = gpg.export_keys(key.fingerprint)
        private_key = gpg.export_keys(key.fingerprint, True, passphrase=passphrase)
        
        import_result = gpg.import_keys(public_key + private_key)
        if not import_result.results or not import_result.results[0]['fingerprint']:
            flash("密钥导入到密钥环失败。")
            return redirect(url_for('generate_key'))
        
        try:
            new_key = Key(
                name_email=name_email,
                public_key=public_key,
                private_key=private_key,
                passphrase=passphrase,
                fingerprint=key.fingerprint
            )
            db.session.add(new_key)
            db.session.commit()
            
            import subprocess
            result = subprocess.run(['gpg', '--list-keys', name_email], 
                                 capture_output=True, text=True)
            if result.returncode != 0:
                raise Exception("无法通过GPG命令行工具检测到密钥")
            
            flash("密钥已成功生成、导入密钥环并保存。")
            return redirect(url_for('index'))
            
        except Exception as e:
            db.session.rollback()
            flash(f"操作失败: {str(e)}")
            return redirect(url_for('generate_key'))
    
    return render_template('index.html')

@app.route('/encrypt_file', methods=['GET', 'POST'])
def encrypt_file():
    if request.method == 'POST':
        file = request.files['file']
        recipient_email = request.form['recipient_email']
        
        gpg = get_gpg()
        
        recipient_key = Key.query.filter_by(name_email=recipient_email).first()
        if not recipient_key:
            flash("Recipient key not found.")
            return redirect(url_for('encrypt_file'))
        
        encrypted_data = gpg.encrypt(file.read(), recipient_key.fingerprint)
        if not encrypted_data.ok:
            flash("Encryption failed.")
            return redirect(url_for('encrypt_file'))
        
        with open(os.path.join('static', 'encrypted_file.gpg'), 'wb') as f:
            f.write(encrypted_data.data)
        
        flash("File encrypted successfully.")
        return redirect(url_for('index'))
    
    return render_template('index.html')

@app.route('/decrypt_file', methods=['GET', 'POST'])
def decrypt_file():
    if request.method == 'POST':
        name_email = request.form.get('name_email')
        file = request.files.get('file')
        passphrase = request.form.get('passphrase')

        if not name_email or not file or not passphrase:
            flash("Please fill in all fields.")
            return redirect(url_for('decrypt_file'))

        gpg = get_gpg()
        
        user = Key.query.filter_by(name_email=name_email).first()
        if not user:
            flash("User key not found.")
            return redirect(url_for('decrypt_file'))

        decrypted_data = gpg.decrypt(file.read(), passphrase=passphrase)
        if not decrypted_data.ok:
            flash("Decryption failed.")
            return redirect(url_for('decrypt_file'))

        decrypted_file_path = os.path.join('static', 'decrypted_file.txt')
        with open(decrypted_file_path, 'wb') as f:
            f.write(str(decrypted_data).encode('utf-8'))

        flash("File decrypted successfully.")
        return redirect(url_for('index'))

    return render_template('index.html')

@app.route('/sign_file', methods=['GET', 'POST'])
def sign_file():
    if request.method == 'POST':
        file = request.files['file']
        passphrase = request.form['passphrase']
        name_email = request.form['name_email']
        
        gpg = get_gpg()
        
        user = Key.query.filter_by(name_email=name_email).first()
        if not user:
            flash("User key not found.")
            return redirect(url_for('sign_file'))
        
        signed_data = gpg.sign(file.read(), keyid=user.fingerprint, passphrase=passphrase)
        if not signed_data:
            flash("Signing failed.")
            return redirect(url_for('sign_file'))
        
        with open(os.path.join('static', 'signed_file.asc'), 'wb') as f:
            f.write(str(signed_data).encode('utf-8'))
        
        flash("File signed successfully.")
        return redirect(url_for('index'))
    
    return render_template('index.html')

import pickle
@app.route('/verify_signature', methods=['GET', 'POST'])
def verify_signature():
    if request.method == 'POST':
        file = request.files.get('file')
        signature = request.files.get('signature')
    
        if not signature:
            flash("Please upload both the file and the signature.")
            return redirect(url_for('verify_signature'))

        gpg = get_gpg()
        
        verified = gpg.verify_file(signature)

        if not verified:
            flash("Signature verification failed.")
        else:
            # 创建包含验证信息的可读文本
            verification_info = (
                f"Signature Verification Results:\n"
                f"------------------------\n"
                f"Username: {verified.username}\n"
                f"Key ID: {verified.key_id}\n"
                f"Signature timestamp: {verified.timestamp}\n"
                f"Status: {'Valid' if verified.valid else 'Invalid'}\n"
                f"Fingerprint: {verified.fingerprint}\n"
                f"Trust level: {verified.trust_level}\n"
                f"Trust text: {verified.trust_text}\n"
            )

            # 保存为文本文件
            result_filename = os.path.join('static', f"verification_result_{file.filename}.txt")
            with open(result_filename, 'w', encoding='utf-8') as f:
                f.write(verification_info)
            
            flash(f"Verification result saved as {result_filename}")
        
        return redirect(url_for('index'))
    
    return render_template('index.html')

if __name__ == '__main__':
    with app.app_context():
        db.create_all()
    app.run(debug=True)